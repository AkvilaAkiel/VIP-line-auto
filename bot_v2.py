import logging
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, ContextTypes
from flask import Flask, request
import os

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logging.basicConfig(level=logging.INFO)

queue = []
active_break = None

# == –ö–ù–û–ü–ö–ò ==
def main_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üü¢ –î–æ–ª—É—á–∏—Ç–∏—Å—å –¥–æ —á–µ—Ä–≥–∏", callback_data="join")],
        [InlineKeyboardButton("üî¥ –í–∏–π—Ç–∏ –∑ —á–µ—Ä–≥–∏", callback_data="leave")],
        [InlineKeyboardButton("üìã –ü–æ–¥–∏–≤–∏—Ç–∏—Å—å —á–µ—Ä–≥—É", callback_data="queue")],
    ])

# == –ö–û–ú–ê–ù–î–ò ==
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ü—Ä–∏–≤—ñ—Ç! –Ø –±–æ—Ç –¥–ª—è —á–µ—Ä–≥–∏ –Ω–∞ –ø–µ—Ä–µ—Ä–≤—É ‚è≥\n–û–±–µ—Ä–∏ –¥—ñ—é:",
        reply_markup=main_menu()
    )

# == –û–ë–†–û–ë–ö–ê –ö–ù–û–ü–û–ö ==
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global active_break
    query = update.callback_query
    await query.answer()
    user = query.from_user

    if query.data == "join":
        if user.id in [u.id for u in queue]:
            position = [u.id for u in queue].index(user.id) + 1
            await query.edit_message_text(f"–¢–∏ –≤–∂–µ –≤ —á–µ—Ä–∑—ñ. –¢–≤–æ—î –º—ñ—Å—Ü–µ: {position}")
        else:
            queue.append(user)
            await query.edit_message_text("–¢–µ–±–µ –¥–æ–¥–∞–Ω–æ –≤ —á–µ—Ä–≥—É –Ω–∞ –ø–µ—Ä–µ—Ä–≤—É.")
            if active_break is None:
                await start_next_break(context)

    elif query.data == "leave":
        if user in queue:
            queue.remove(user)
            await query.edit_message_text("–¢–µ–±–µ –≤–∏–¥–∞–ª–µ–Ω–æ –∑ —á–µ—Ä–≥–∏.")
        elif user == active_break:
            active_break = None
            await query.edit_message_text("–¢–∏ –≤–∏–π—à–æ–≤ –∑ –ø–µ—Ä–µ—Ä–≤–∏ –¥–æ—Å—Ç—Ä–æ–∫–æ–≤–æ.")
            await notify_next(context)
        else:
            await query.edit_message_text("–¢–µ–±–µ –Ω–µ–º–∞—î –≤ —á–µ—Ä–∑—ñ.")
    
    elif query.data == "queue":
        if not queue:
            text = "–ß–µ—Ä–≥–∞ –ø–æ—Ä–æ–∂–Ω—è."
        else:
            names = [f"{i+1}. {u.first_name}" for i, u in enumerate(queue)]
            text = "–ü–æ—Ç–æ—á–Ω–∞ —á–µ—Ä–≥–∞:\n" + "\n".join(names)
        await query.edit_message_text(text, reply_markup=main_menu())

# == –õ–û–ì–Ü–ö–ê –ü–ï–†–ï–†–í–ò ==
async def start_next_break(context: ContextTypes.DEFAULT_TYPE):
    global active_break
    if not queue:
        return

    active_break = queue.pop(0)
    chat_id = active_break.id

    await context.bot.send_message(chat_id=chat_id, text="üü¢ –¢–≤–æ—è —á–µ—Ä–≥–∞! –ü–æ—á–∞–ª–∞—Å—å –ø–µ—Ä–µ—Ä–≤–∞ –Ω–∞ 10 —Ö–≤–∏–ª–∏–Ω ‚è≥")

    await asyncio.sleep(9 * 60)
    await context.bot.send_message(chat_id=chat_id, text="‚ö†Ô∏è –ó–∞–ª–∏—à–∏–ª–∞—Å—å 1 —Ö–≤–∏–ª–∏–Ω–∞ –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –ø–µ—Ä–µ—Ä–≤–∏.")

    await asyncio.sleep(60)
    await context.bot.send_message(chat_id=chat_id, text="üîö –¢–≤–æ—è –ø–µ—Ä–µ—Ä–≤–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
    active_break = None
    await notify_next(context)

async def notify_next(context: ContextTypes.DEFAULT_TYPE):
    if queue:
        next_user = queue[0]
        await context.bot.send_message(chat_id=next_user.id, text="üîî –¢–∏ –Ω–∞—Å—Ç—É–ø–Ω–∏–π –Ω–∞ –ø–µ—Ä–µ—Ä–≤—É!")
        await start_next_break(context)

# == FLASK –î–õ–Ø WEBHOOK ==
app = Flask(__name__)

@app.route('/webhook', methods=['POST'])
def webhook():
    json_str = request.get_data().decode('UTF-8')
    update = Update.de_json(json_str, application.bot)
    application.update_queue.put(update)
    return 'OK'

if __name__ == "__main__":
    # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –±–æ—Ç–∞
    application = ApplicationBuilder().token("YOUR_BOT_TOKEN").build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button_handler))

    # –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è webhook
    webhook_url = os.getenv('WEBHOOK_URL')  # –ù–∞–ø—Ä–∏–∫–ª–∞–¥, https://your-app-name.onrender.com/webhook
    application.bot.set_webhook(webhook_url)

    # –ó–∞–ø—É—Å–∫ Flask-—Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è –æ–±—Ä–æ–±–∫–∏ –∑–∞–ø–∏—Ç—ñ–≤ webhook
    app.run(host='0.0.0.0', port=5000)
